<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/SPINNER_FEATURE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SPINNER_FEATURE.md" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="# Spinner Feature - Implementation Summary&#10;&#10;## ✅ COMPLETED: Loading Spinner on Translate Button&#10;&#10;The translate button now shows an animated spinner while translation is in progress!&#10;&#10;**FIXED**: Translation now runs asynchronously in background thread, ensuring spinner is always visible.&#10;&#10;---&#10;&#10;## What Was Implemented&#10;&#10;### 1. **Visual Feedback During Translation**&#10;&#10;- **Before Translation**: Triangle icon (▶) appears on the button&#10;- **During Translation**: Animated circular spinner replaces the triangle&#10;- **After Translation**: Triangle icon returns&#10;&#10;### 2. **Smooth Animation**&#10;&#10;- The spinner is a rotating arc (270° partial circle)&#10;- Rotates continuously at 1 second per full rotation&#10;- White color matching the button theme&#10;- Smooth animation using JavaFX RotateTransition&#10;&#10;### 3. **Automatic State Management**&#10;&#10;The spinner automatically:&#10;- ✅ Shows when you click the Translate button&#10;- ✅ Shows when you press Ctrl+Enter in the source text area&#10;- ✅ Hides when translation completes successfully&#10;- ✅ Works with clipboard monitoring translations&#10;- ✅ **Runs translation in background thread** (UI stays responsive)&#10;&#10;---&#10;&#10;## Technical Implementation&#10;&#10;### Key Architecture Changes&#10;&#10;**Background Threading**: Translation now runs asynchronously&#10;- `Tools.callEvent()` creates a new background thread for translation&#10;- UI thread immediately shows the spinner without blocking&#10;- Background thread performs the Google Translate API call&#10;- UI thread is notified when translation completes and hides spinner&#10;&#10;### New Class Members&#10;```java&#10;private Button translateButton;          // Reference to the translate button&#10;private Polygon triangleIcon;            // The triangle play icon&#10;private Arc spinnerIcon;                 // The circular spinner arc&#10;private RotateTransition spinnerAnimation; // Animation for spinner rotation&#10;```&#10;&#10;### Spinner Creation&#10;- **Arc Shape**: 270° arc (leaving 90° gap for visual effect)&#10;- **Size**: 10px radius&#10;- **Stroke**: 3px width, white color&#10;- **Animation**: Infinite rotation, 1 second per cycle&#10;&#10;### State Transitions&#10;1. **User initiates translation** → `performTranslation()` calls `showSpinner()` (UI thread)&#10;2. **Translation processes** → Background thread calls Google Translate API&#10;3. **Translation completes** → Event handler calls `hideSpinner()` (UI thread)&#10;4. **Button reverts** → Triangle icon restored&#10;&#10;---&#10;&#10;## How to Test&#10;&#10;### Run the Application&#10;&#10;```bash&#10;cd /home/bs01595/Downloads/iidict-English-to-Bengali-Dictionary-master&#10;java -jar target/translator-1.0.jar&#10;```&#10;&#10;Or with Maven:&#10;```bash&#10;mvn javafx:run&#10;```&#10;&#10;### Test the Spinner&#10;&#10;1. **Type text** in the source text area (left panel)&#10;2. **Click the translate button** (center bottom, circular button with triangle)&#10;3. ** WATCH**: Triangle immediately changes to spinning arc&#10;4. **⏱️ WAIT**: Spinner rotates while Google Translate API processes (usually 0.5-2 seconds)&#10;5. **✅ RESULT**: Triangle returns when translation appears&#10;&#10;### Alternative Test Methods&#10;&#10;- **Ctrl+Enter**: Type text and press Ctrl+Enter → spinner appears immediately&#10;- **Clipboard**: Copy text → automatic translation shows spinner&#10;- **Multiple Translations**: Try several translations in sequence&#10;- **Long Text**: Translate longer text to see spinner for longer duration&#10;&#10;---&#10;&#10;## Visual Design&#10;&#10;### Triangle Icon (Default State)&#10;```&#10;     ▲&#10;    ◄►  ← White triangle pointing right&#10;     ▼&#10;```&#10;- Simple, recognizable &quot;play&quot; or &quot;go&quot; symbol&#10;- Clear indication that button is ready&#10;&#10;### Spinner Icon (Loading State)&#10;```&#10;    ◜◝&#10;   ◟  ◞  ← Rotating arc (270° coverage)&#10;    ◜◝&#10;```&#10;- Animated rotation gives clear feedback&#10;- Partial circle creates modern loading effect&#10;- Continuous motion indicates active processing&#10;&#10;---&#10;&#10;## User Experience Benefits&#10;&#10;1. **Clear Feedback**: Users know translation is in progress&#10;2. **No Confusion**: Button state clearly shows activity&#10;3. **Professional Look**: Smooth animation looks polished&#10;4. **Consistent Behavior**: Works with all translation triggers&#10;5. **No Blocking**: UI remains responsive during translation (async processing)&#10;6. **Immediate Visual Response**: Spinner shows instantly when button is clicked&#10;&#10;---&#10;&#10;## Code Changes Made&#10;&#10;### Files Modified&#10;1. **`WindowFX.java`** - Added spinner UI functionality&#10;2. **`Tools.java`** - Added background threading for translation&#10;&#10;### Key Methods Added in WindowFX.java&#10;```java&#10;private void showSpinner()    // Display and start spinner animation&#10;private void hideSpinner()    // Stop spinner and restore triangle&#10;```&#10;&#10;### Key Methods Modified in WindowFX.java&#10;```java&#10;private void performTranslation()  // Shows spinner immediately before translating&#10;private void setupEventHandlers()  // Hides spinner on UI thread after translation&#10;```&#10;&#10;### Key Methods Modified in Tools.java&#10;```java&#10;public void callEvent(String type)  // Now runs translation in background thread&#10;public void setTranslationStartCallback(Event callback)  // New callback for translation start&#10;```&#10;&#10;### New Imports Added&#10;```java&#10;import javafx.animation.RotateTransition;&#10;import javafx.scene.shape.Arc;&#10;import javafx.scene.shape.ArcType;&#10;import javafx.util.Duration;&#10;```&#10;&#10;---&#10;&#10;## Performance Notes&#10;&#10;- ✅ **Lightweight**: Simple arc shape with rotation&#10;- ✅ **GPU Accelerated**: JavaFX handles animation efficiently&#10;- ✅ **No Lag**: Spinner shows immediately on button click&#10;- ✅ **Clean Stop**: Animation stops cleanly when translation completes&#10;- ✅ **Memory Efficient**: Spinner created once and reused&#10;- ✅ **Non-Blocking**: UI thread never blocked by translation&#10;- ✅ **Background Processing**: Google Translate API calls run in separate thread&#10;&#10;---&#10;&#10;## Bug Fixes Applied&#10;&#10;### Issue: Spinner Not Visible&#10;**Problem**: Translation was running synchronously on UI thread, completing before spinner could render&#10;**Solution**: &#10;- Moved translation work to background thread&#10;- UI thread shows spinner immediately&#10;- Background thread performs API call&#10;- UI thread notified when complete via Platform.runLater()&#10;&#10;### Implementation Details&#10;```java&#10;// Tools.java - callEvent() method&#10;new Thread(() -&gt; {&#10;    try {&#10;        latest_translation = meaning(textToTranslate);&#10;        if(latest_translation.isEmpty()) return;&#10;        for(Event evt:events){&#10;            evt.event();  // Notify UI thread when done&#10;        }&#10;    } catch (Exception e) {&#10;        System.err.println(&quot;Translation error: &quot; + e.getMessage());&#10;    }&#10;}).start();&#10;```&#10;&#10;---&#10;&#10;## Troubleshooting&#10;&#10;### If spinner doesn't appear:&#10;- ✅ **FIXED**: Translation now runs asynchronously&#10;- Check console for any exceptions during startup&#10;- Verify button is properly initialized&#10;&#10;### If spinner doesn't stop:&#10;- Check console for translation errors&#10;- Ensure event handler is properly registered&#10;- Translation might have failed silently (check network connection)&#10;&#10;### If translation seems slow:&#10;- Normal behavior: Google Translate API can take 0.5-2 seconds&#10;- Spinner provides visual feedback during this time&#10;- Check internet connection speed&#10;&#10;---&#10;&#10;## Summary&#10;&#10;Your Universal Translator now provides clear visual feedback during translation:&#10;&#10;✅ **Triangle icon** → Ready to translate&#10;✅ **Spinning arc** → Translation in progress (API call active)&#10;✅ **Triangle returns** → Translation complete&#10;&#10;The feature works seamlessly with:&#10;- Manual button clicks&#10;- Ctrl+Enter keyboard shortcut&#10;- Automatic clipboard monitoring&#10;&#10;**Key Improvement**: Translation runs in background thread, ensuring the spinner is always visible and the UI stays responsive.&#10;&#10;---&#10;&#10;**Status**: ✅ Fully Implemented and Tested&#10;**Build**: ✅ Successful (target/translator-1.0.jar)&#10;**Bug Fixed**: ✅ Async translation ensures spinner visibility&#10;**Ready to Use**: ✅ Yes&#10;&#10;---&#10;&#10;**Last Updated**: November 12, 2025" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/com/iishanto/Tools.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/com/iishanto/Tools.java" />
              <option name="originalContent" value="package com.iishanto;&#10;&#10;import java.io.InputStream;&#10;import java.util.*;&#10;&#10;public class Tools {&#10;    private static Tools tools=null;&#10;    private final List&lt;String&gt; list=new ArrayList&lt;&gt;();&#10;    private final List&lt;Event&gt; events=new ArrayList&lt;&gt;();&#10;    String latest_translation=&quot;&quot;;&#10;    String latest_source=&quot;&quot;;  // Store source text separately&#10;&#10;    // Language settings&#10;    private String sourceLanguage = &quot;auto&quot;;&#10;    private String targetLanguage = &quot;bn&quot;;&#10;&#10;    Tools(){&#10;        System.out.println(&quot;Translator initialized with Google Translate API&quot;);&#10;    }&#10;&#10;    public void setSourceLanguage(String lang) {&#10;        this.sourceLanguage = lang;&#10;    }&#10;&#10;    public void setTargetLanguage(String lang) {&#10;        this.targetLanguage = lang;&#10;    }&#10;&#10;    public InputStream getRes(String file){&#10;        // Remove leading slash if present&#10;        String resourcePath = file.startsWith(&quot;/&quot;) ? file.substring(1) : file;&#10;        // Try with res/ prefix&#10;        InputStream is = Tools.class.getClassLoader().getResourceAsStream(&quot;res/&quot; + resourcePath);&#10;        if (is == null) {&#10;            // Try without res/ prefix&#10;            is = Tools.class.getClassLoader().getResourceAsStream(resourcePath);&#10;        }&#10;        if (is == null) {&#10;            // Try with leading slash (original method)&#10;            is = Tools.class.getResourceAsStream(file);&#10;        }&#10;        return is;&#10;    }&#10;&#10;    String meaning(String upword){&#10;        List&lt;String&gt; theSentence=new ArrayList&lt;&gt;();&#10;        theSentence.add(upword);&#10;        try{&#10;            // Use Google Translate with the selected languages&#10;            List&lt;String&gt; translations=GoogleTranslateClient.getInstance().translateList(theSentence, sourceLanguage, targetLanguage);&#10;            if(translations.isEmpty()){&#10;                return &quot;Translation not available!&quot;;&#10;            }&#10;            // Decode HTML entities in the translation result&#10;            return decodeHtmlEntities(translations.get(0));&#10;        }catch(Exception e){&#10;            return &quot;Translation error: &quot; + e.getMessage();&#10;        }&#10;    }&#10;&#10;    public void callEvent(String type){&#10;        if(type.equals(&quot;new_text&quot;)){&#10;            latest_translation=&quot;&quot;;&#10;            latest_source=&quot;&quot;;&#10;            String word= list.get(list.size() - 1);&#10;            word=word.trim();&#10;            // Decode HTML entities in source text&#10;            latest_source = decodeHtmlEntities(word);  // Store source separately&#10;            latest_translation = meaning(word);  // Store translation only (already decoded in meaning())&#10;            if(latest_translation.isEmpty()) return;&#10;            for(Event evt:events){&#10;                evt.event();&#10;            }&#10;        }&#10;    }&#10;&#10;    public String getLatestTranslation(){&#10;        return latest_translation;&#10;    }&#10;&#10;    public String getLatestSource(){&#10;        return latest_source;&#10;    }&#10;&#10;    public String getLatestTranslationFormatted(){&#10;        return latest_source + &quot;: &quot; + latest_translation + &quot;\n&quot;;&#10;    }&#10;&#10;    public void regNewText(String s){&#10;        list.add(s);&#10;        if(list.size()&gt;10){&#10;            list.remove(0);&#10;        }&#10;    }&#10;&#10;    public void addEvent(Event evt){&#10;        events.add(evt);&#10;    }&#10;&#10;    public static Tools getConfig(){&#10;        if(tools==null){&#10;            tools=new Tools();&#10;        }&#10;        return tools;&#10;    }&#10;&#10;    // Decode HTML entities to proper characters&#10;    public static String decodeHtmlEntities(String text) {&#10;        if (text == null || text.isEmpty()) {&#10;            return text;&#10;        }&#10;&#10;        // Decode common HTML entities&#10;        text = text.replace(&quot;&amp;quot;&quot;, &quot;\&quot;&quot;);&#10;        text = text.replace(&quot;&amp;apos;&quot;, &quot;'&quot;);&#10;        text = text.replace(&quot;&amp;lt;&quot;, &quot;&lt;&quot;);&#10;        text = text.replace(&quot;&amp;gt;&quot;, &quot;&gt;&quot;);&#10;        text = text.replace(&quot;&amp;amp;&quot;, &quot;&amp;&quot;);  // Must be last to avoid double-decoding&#10;        text = text.replace(&quot;&amp;#39;&quot;, &quot;'&quot;);&#10;        text = text.replace(&quot;&amp;#34;&quot;, &quot;\&quot;&quot;);&#10;        text = text.replace(&quot;&amp;nbsp;&quot;, &quot; &quot;);&#10;&#10;        // Decode numeric character references (e.g., &amp;#8220; &amp;#8221;)&#10;        while (text.contains(&quot;&amp;#&quot;)) {&#10;            int start = text.indexOf(&quot;&amp;#&quot;);&#10;            int end = text.indexOf(&quot;;&quot;, start);&#10;            if (end &gt; start) {&#10;                try {&#10;                    String numStr = text.substring(start + 2, end);&#10;                    int charCode;&#10;                    if (numStr.startsWith(&quot;x&quot;) || numStr.startsWith(&quot;X&quot;)) {&#10;                        // Hexadecimal&#10;                        charCode = Integer.parseInt(numStr.substring(1), 16);&#10;                    } else {&#10;                        // Decimal&#10;                        charCode = Integer.parseInt(numStr);&#10;                    }&#10;                    char decodedChar = (char) charCode;&#10;                    text = text.substring(0, start) + decodedChar + text.substring(end + 1);&#10;                } catch (NumberFormatException e) {&#10;                    break; // Invalid format, stop trying&#10;                }&#10;            } else {&#10;                break;&#10;            }&#10;        }&#10;&#10;        return text;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.iishanto;&#10;&#10;import java.io.InputStream;&#10;import java.util.*;&#10;&#10;public class Tools {&#10;    private static Tools tools=null;&#10;    private final List&lt;String&gt; list=new ArrayList&lt;&gt;();&#10;    private final List&lt;Event&gt; events=new ArrayList&lt;&gt;();&#10;    String latest_translation=&quot;&quot;;&#10;    String latest_source=&quot;&quot;;  // Store source text separately&#10;&#10;    // Language settings&#10;    private String sourceLanguage = &quot;auto&quot;;&#10;    private String targetLanguage = &quot;bn&quot;;&#10;&#10;    // Callback for translation start&#10;    private Event translationStartCallback = null;&#10;&#10;    Tools(){&#10;        System.out.println(&quot;Translator initialized with Google Translate API&quot;);&#10;    }&#10;&#10;    public void setSourceLanguage(String lang) {&#10;        this.sourceLanguage = lang;&#10;    }&#10;&#10;    public void setTargetLanguage(String lang) {&#10;        this.targetLanguage = lang;&#10;    }&#10;&#10;    public void setTranslationStartCallback(Event callback) {&#10;        this.translationStartCallback = callback;&#10;    }&#10;&#10;    public InputStream getRes(String file){&#10;        // Remove leading slash if present&#10;        String resourcePath = file.startsWith(&quot;/&quot;) ? file.substring(1) : file;&#10;        // Try with res/ prefix&#10;        InputStream is = Tools.class.getClassLoader().getResourceAsStream(&quot;res/&quot; + resourcePath);&#10;        if (is == null) {&#10;            // Try without res/ prefix&#10;            is = Tools.class.getClassLoader().getResourceAsStream(resourcePath);&#10;        }&#10;        if (is == null) {&#10;            // Try with leading slash (original method)&#10;            is = Tools.class.getResourceAsStream(file);&#10;        }&#10;        return is;&#10;    }&#10;&#10;    String meaning(String upword){&#10;        List&lt;String&gt; theSentence=new ArrayList&lt;&gt;();&#10;        theSentence.add(upword);&#10;        try{&#10;            // Use Google Translate with the selected languages&#10;            List&lt;String&gt; translations=GoogleTranslateClient.getInstance().translateList(theSentence, sourceLanguage, targetLanguage);&#10;            if(translations.isEmpty()){&#10;                return &quot;Translation not available!&quot;;&#10;            }&#10;            // Decode HTML entities in the translation result&#10;            return decodeHtmlEntities(translations.get(0));&#10;        }catch(Exception e){&#10;            return &quot;Translation error: &quot; + e.getMessage();&#10;        }&#10;    }&#10;&#10;    public void callEvent(String type){&#10;        if(type.equals(&quot;new_text&quot;)){&#10;            latest_translation=&quot;&quot;;&#10;            latest_source=&quot;&quot;;&#10;            String word= list.get(list.size() - 1);&#10;            word=word.trim();&#10;            // Decode HTML entities in source text&#10;            latest_source = decodeHtmlEntities(word);  // Store source separately&#10;            &#10;            // Notify translation started&#10;            if (translationStartCallback != null) {&#10;                translationStartCallback.event();&#10;            }&#10;            &#10;            // Run translation in background thread&#10;            final String textToTranslate = word;&#10;            new Thread(() -&gt; {&#10;                try {&#10;                    latest_translation = meaning(textToTranslate);  // Store translation only (already decoded in meaning())&#10;                    if(latest_translation.isEmpty()) return;&#10;                    for(Event evt:events){&#10;                        evt.event();&#10;                    }&#10;                } catch (Exception e) {&#10;                    System.err.println(&quot;Translation error: &quot; + e.getMessage());&#10;                    e.printStackTrace();&#10;                }&#10;            }).start();&#10;        }&#10;    }&#10;&#10;    public String getLatestTranslation(){&#10;        return latest_translation;&#10;    }&#10;&#10;    public String getLatestSource(){&#10;        return latest_source;&#10;    }&#10;&#10;    public String getLatestTranslationFormatted(){&#10;        return latest_source + &quot;: &quot; + latest_translation + &quot;\n&quot;;&#10;    }&#10;&#10;    public void regNewText(String s){&#10;        list.add(s);&#10;        if(list.size()&gt;10){&#10;            list.remove(0);&#10;        }&#10;    }&#10;&#10;    public void addEvent(Event evt){&#10;        events.add(evt);&#10;    }&#10;&#10;    public static Tools getConfig(){&#10;        if(tools==null){&#10;            tools=new Tools();&#10;        }&#10;        return tools;&#10;    }&#10;&#10;    // Decode HTML entities to proper characters&#10;    public static String decodeHtmlEntities(String text) {&#10;        if (text == null || text.isEmpty()) {&#10;            return text;&#10;        }&#10;&#10;        // Decode common HTML entities&#10;        text = text.replace(&quot;&amp;quot;&quot;, &quot;\&quot;&quot;);&#10;        text = text.replace(&quot;&amp;apos;&quot;, &quot;'&quot;);&#10;        text = text.replace(&quot;&amp;lt;&quot;, &quot;&lt;&quot;);&#10;        text = text.replace(&quot;&amp;gt;&quot;, &quot;&gt;&quot;);&#10;        text = text.replace(&quot;&amp;amp;&quot;, &quot;&amp;&quot;);  // Must be last to avoid double-decoding&#10;        text = text.replace(&quot;&amp;#39;&quot;, &quot;'&quot;);&#10;        text = text.replace(&quot;&amp;#34;&quot;, &quot;\&quot;&quot;);&#10;        text = text.replace(&quot;&amp;nbsp;&quot;, &quot; &quot;);&#10;&#10;        // Decode numeric character references (e.g., &amp;#8220; &amp;#8221;)&#10;        while (text.contains(&quot;&amp;#&quot;)) {&#10;            int start = text.indexOf(&quot;&amp;#&quot;);&#10;            int end = text.indexOf(&quot;;&quot;, start);&#10;            if (end &gt; start) {&#10;                try {&#10;                    String numStr = text.substring(start + 2, end);&#10;                    int charCode;&#10;                    if (numStr.startsWith(&quot;x&quot;) || numStr.startsWith(&quot;X&quot;)) {&#10;                        // Hexadecimal&#10;                        charCode = Integer.parseInt(numStr.substring(1), 16);&#10;                    } else {&#10;                        // Decimal&#10;                        charCode = Integer.parseInt(numStr);&#10;                    }&#10;                    char decodedChar = (char) charCode;&#10;                    text = text.substring(0, start) + decodedChar + text.substring(end + 1);&#10;                } catch (NumberFormatException e) {&#10;                    break; // Invalid format, stop trying&#10;                }&#10;            } else {&#10;                break;&#10;            }&#10;        }&#10;&#10;        return text;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/com/iishanto/WindowFX.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/com/iishanto/WindowFX.java" />
              <option name="originalContent" value="package com.iishanto;&#10;&#10;import javafx.application.Application;&#10;import javafx.application.Platform;&#10;import javafx.geometry.Insets;&#10;import javafx.geometry.Pos;&#10;import javafx.scene.Scene;&#10;import javafx.scene.control.*;&#10;import javafx.scene.input.KeyCode;&#10;import javafx.scene.layout.*;&#10;import javafx.scene.paint.Color;&#10;import javafx.scene.shape.Polygon;&#10;import javafx.scene.text.Font;&#10;import javafx.stage.Modality;&#10;import javafx.stage.Stage;&#10;import javafx.scene.image.Image;&#10;&#10;import java.io.InputStream;&#10;import java.io.InputStreamReader;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Objects;&#10;&#10;import com.google.gson.Gson;&#10;import com.google.gson.JsonObject;&#10;import com.google.gson.JsonArray;&#10;&#10;public class WindowFX extends Application {&#10;    private Stage primaryStage;&#10;    private ComboBox&lt;LanguageItem&gt; sourceLanguageCombo;&#10;    private ComboBox&lt;LanguageItem&gt; targetLanguageCombo;&#10;    private TextArea sourceTextArea;&#10;    private TextArea translationTextArea;&#10;    private final List&lt;String&gt; translationHistory = new ArrayList&lt;&gt;();&#10;    private boolean isAlwaysOnTop = true;&#10;    private Button alwaysOnTopButton;&#10;&#10;    // Language class to hold language code and display name&#10;    private static class LanguageItem {&#10;        String code;&#10;        String name;&#10;&#10;        LanguageItem(String code, String name) {&#10;            this.code = code;&#10;            this.name = name;&#10;        }&#10;&#10;        @Override&#10;        public String toString() {&#10;            return name;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void start(Stage stage) {&#10;        this.primaryStage = stage;&#10;        primaryStage.setTitle(&quot;Universal Translator&quot;);&#10;        primaryStage.setAlwaysOnTop(true);&#10;&#10;        // Initialize font rendering system&#10;        initializeFontRendering();&#10;&#10;        // Load icon&#10;        loadIcon();&#10;&#10;        // Create UI&#10;        BorderPane root = new BorderPane();&#10;        root.getStyleClass().add(&quot;main-container&quot;);&#10;&#10;        // Top toolbar&#10;        HBox toolbar = createToolbar();&#10;        root.setTop(toolbar);&#10;&#10;        // Main content with overlay button&#10;        StackPane mainContent = createMainContent();&#10;        root.setCenter(mainContent);&#10;&#10;        // Status bar&#10;        HBox statusBar = createStatusBar();&#10;        root.setBottom(statusBar);&#10;&#10;        Scene scene = new Scene(root, 600, 300);&#10;&#10;        // Load CSS stylesheet&#10;        try {&#10;            InputStream cssStream = getClass().getResourceAsStream(&quot;/res/dark-theme.css&quot;);&#10;            if (cssStream != null) {&#10;                cssStream.close();&#10;                scene.getStylesheets().add(getClass().getResource(&quot;/res/dark-theme.css&quot;).toExternalForm());&#10;                System.out.println(&quot;✓ Dark theme CSS loaded successfully&quot;);&#10;            }&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Warning: Could not load dark-theme.css: &quot; + e.getMessage());&#10;        }&#10;&#10;        primaryStage.setScene(scene);&#10;        primaryStage.setMinWidth(600);&#10;        primaryStage.setMinHeight(100);&#10;&#10;        // Add shutdown hook for proper cleanup&#10;        primaryStage.setOnCloseRequest(event -&gt; {&#10;            System.out.println(&quot;Application closing...&quot;);&#10;            shutdown();&#10;        });&#10;&#10;        // Setup event handlers after UI is created&#10;        Platform.runLater(this::setupEventHandlers);&#10;&#10;        primaryStage.show();&#10;&#10;        System.out.println(&quot;=== JavaFX Window Initialized ===&quot;);&#10;        System.out.println(&quot;✓ Using OS native font rendering&quot;);&#10;        System.out.println(&quot;✓ Hardware-accelerated rendering enabled&quot;);&#10;    }&#10;&#10;    /**&#10;     * Initialize OS font rendering system with proper fallback for international characters&#10;     */&#10;    private void initializeFontRendering() {&#10;        System.out.println(&quot;=== Initializing OS Font Rendering ===&quot;);&#10;&#10;        // Load system fonts explicitly&#10;        loadSystemFonts();&#10;&#10;        // Get all available system fonts&#10;        List&lt;String&gt; fontFamilies = Font.getFamilies();&#10;&#10;        // Check for important international fonts&#10;        boolean hasJapanese = false;&#10;        boolean hasChinese = false;&#10;        boolean hasBengali = false;&#10;        boolean hasArabic = false;&#10;        boolean hasKorean = false;&#10;&#10;        List&lt;String&gt; cjkFonts = new ArrayList&lt;&gt;();&#10;        List&lt;String&gt; indicFonts = new ArrayList&lt;&gt;();&#10;        List&lt;String&gt; arabicFonts = new ArrayList&lt;&gt;();&#10;&#10;        for (String family : fontFamilies) {&#10;            String lowerFamily = family.toLowerCase();&#10;&#10;            // Japanese fonts&#10;            if (lowerFamily.contains(&quot;noto serif cjk jp&quot;) ||&#10;                lowerFamily.contains(&quot;noto sans cjk jp&quot;) ||&#10;                lowerFamily.contains(&quot;noto sans jp&quot;) ||&#10;                lowerFamily.contains(&quot;ms gothic&quot;) ||&#10;                lowerFamily.contains(&quot;meiryo&quot;) ||&#10;                lowerFamily.contains(&quot;hiragino&quot;) ||&#10;                lowerFamily.contains(&quot;ipagothic&quot;) ||&#10;                lowerFamily.contains(&quot;takao&quot;)) {&#10;                hasJapanese = true;&#10;                cjkFonts.add(family);&#10;            }&#10;&#10;            // Chinese fonts&#10;            if (lowerFamily.contains(&quot;noto serif cjk&quot;) ||&#10;                lowerFamily.contains(&quot;noto sans cjk&quot;) ||&#10;                lowerFamily.contains(&quot;noto sans sc&quot;) ||&#10;                lowerFamily.contains(&quot;noto sans tc&quot;) ||&#10;                lowerFamily.contains(&quot;microsoft yahei&quot;) ||&#10;                lowerFamily.contains(&quot;simsun&quot;) ||&#10;                lowerFamily.contains(&quot;wqy&quot;)) {&#10;                hasChinese = true;&#10;                cjkFonts.add(family);&#10;            }&#10;&#10;            // Korean fonts&#10;            if (lowerFamily.contains(&quot;noto sans kr&quot;) ||&#10;                lowerFamily.contains(&quot;noto serif cjk kr&quot;) ||&#10;                lowerFamily.contains(&quot;noto sans cjk kr&quot;) ||&#10;                lowerFamily.contains(&quot;malgun&quot;) ||&#10;                lowerFamily.contains(&quot;nanum&quot;)) {&#10;                hasKorean = true;&#10;                cjkFonts.add(family);&#10;            }&#10;&#10;            // Bengali fonts&#10;            if (lowerFamily.contains(&quot;noto sans bengali&quot;) ||&#10;                lowerFamily.contains(&quot;kalpurush&quot;) ||&#10;                lowerFamily.contains(&quot;lohit bengali&quot;) ||&#10;                lowerFamily.contains(&quot;mukti&quot;)) {&#10;                hasBengali = true;&#10;                indicFonts.add(family);&#10;            }&#10;&#10;            // Arabic fonts&#10;            if (lowerFamily.contains(&quot;noto sans arabic&quot;) ||&#10;                lowerFamily.contains(&quot;arabic&quot;) ||&#10;                lowerFamily.contains(&quot;droid arabic&quot;)) {&#10;                hasArabic = true;&#10;                arabicFonts.add(family);&#10;            }&#10;        }&#10;&#10;        // Report font availability&#10;        System.out.println(&quot;Font Support Status:&quot;);&#10;        System.out.println(&quot;  Japanese: &quot; + (hasJapanese ? &quot;✓ Available&quot; : &quot;✗ Missing&quot;));&#10;        System.out.println(&quot;  Chinese: &quot; + (hasChinese ? &quot;✓ Available&quot; : &quot;✗ Missing&quot;));&#10;        System.out.println(&quot;  Korean: &quot; + (hasKorean ? &quot;✓ Available&quot; : &quot;✗ Missing&quot;));&#10;        System.out.println(&quot;  Bengali: &quot; + (hasBengali ? &quot;✓ Available&quot; : &quot;✗ Missing&quot;));&#10;        System.out.println(&quot;  Arabic: &quot; + (hasArabic ? &quot;✓ Available&quot; : &quot;✗ Missing&quot;));&#10;&#10;        if (!cjkFonts.isEmpty()) {&#10;            System.out.println(&quot;\nAvailable CJK Fonts: &quot; + String.join(&quot;, &quot;, cjkFonts.subList(0, Math.min(3, cjkFonts.size()))));&#10;        }&#10;        if (!indicFonts.isEmpty()) {&#10;            System.out.println(&quot;Available Indic Fonts: &quot; + String.join(&quot;, &quot;, indicFonts));&#10;        }&#10;        if (!arabicFonts.isEmpty()) {&#10;            System.out.println(&quot;Available Arabic Fonts: &quot; + String.join(&quot;, &quot;, arabicFonts));&#10;        }&#10;&#10;        // Test character rendering&#10;        testFontRendering();&#10;&#10;        // Set system properties for better font rendering&#10;        System.setProperty(&quot;prism.lcdtext&quot;, &quot;true&quot;);&#10;        System.setProperty(&quot;prism.text&quot;, &quot;t2k&quot;);&#10;        System.setProperty(&quot;prism.allowhidpi&quot;, &quot;true&quot;);&#10;&#10;        System.out.println(&quot;✓ Font rendering system initialized&quot;);&#10;    }&#10;&#10;    /**&#10;     * Explicitly load system fonts from common paths&#10;     */&#10;    private void loadSystemFonts() {&#10;        String[] fontPaths = {&#10;            &quot;/usr/share/fonts/opentype/noto/&quot;,&#10;            &quot;/usr/share/fonts/truetype/noto/&quot;,&#10;            &quot;/usr/share/fonts/opentype/&quot;,&#10;            &quot;/usr/share/fonts/truetype/&quot;,&#10;            &quot;/usr/local/share/fonts/&quot;,&#10;            System.getProperty(&quot;user.home&quot;) + &quot;/.fonts/&quot;&#10;        };&#10;&#10;        for (String path : fontPaths) {&#10;            java.io.File fontDir = new java.io.File(path);&#10;            if (fontDir.exists() &amp;&amp; fontDir.isDirectory()) {&#10;                java.io.File[] fontFiles = fontDir.listFiles((dir, name) -&gt; {&#10;                    String lower = name.toLowerCase();&#10;                    return (lower.endsWith(&quot;.ttf&quot;) || lower.endsWith(&quot;.ttc&quot;) || lower.endsWith(&quot;.otf&quot;)) &amp;&amp;&#10;                           (lower.contains(&quot;noto&quot;) || lower.contains(&quot;cjk&quot;) || lower.contains(&quot;bengali&quot;));&#10;                });&#10;&#10;                if (fontFiles != null) {&#10;                    for (java.io.File fontFile : fontFiles) {&#10;                        try {&#10;                            Font.loadFont(new java.io.FileInputStream(fontFile), 14);&#10;                            System.out.println(&quot;  Loaded: &quot; + fontFile.getName());&#10;                        } catch (Exception e) {&#10;                            // Silently skip fonts that can't be loaded&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Test if critical characters can be rendered&#10;     */&#10;    private void testFontRendering() {&#10;        Font testFont = Font.getDefault();&#10;&#10;        // Test characters from different scripts&#10;        char[] testChars = {&#10;            'あ', // Japanese Hiragana&#10;            'ア', // Japanese Katakana&#10;            '漢', // Chinese/Japanese Kanji&#10;            'ব', // Bengali&#10;            'م', // Arabic&#10;            '한', // Korean Hangul&#10;            'ก', // Thai&#10;            'א'  // Hebrew&#10;        };&#10;&#10;        String[] scriptNames = {&#10;            &quot;Japanese (Hiragana)&quot;,&#10;            &quot;Japanese (Katakana)&quot;,&#10;            &quot;CJK (Kanji/Hanzi)&quot;,&#10;            &quot;Bengali&quot;,&#10;            &quot;Arabic&quot;,&#10;            &quot;Korean&quot;,&#10;            &quot;Thai&quot;,&#10;            &quot;Hebrew&quot;&#10;        };&#10;&#10;        System.out.println(&quot;\nCharacter Rendering Test:&quot;);&#10;        for (int i = 0; i &lt; testChars.length; i++) {&#10;            // Note: JavaFX doesn't have a direct canDisplay method, but the OS will handle fallback&#10;            System.out.println(&quot;  &quot; + scriptNames[i] + &quot; (&quot; + testChars[i] + &quot;): Will use OS font fallback&quot;);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void stop() throws Exception {&#10;        System.out.println(&quot;JavaFX Application stopping...&quot;);&#10;        shutdown();&#10;        super.stop();&#10;    }&#10;&#10;    private void shutdown() {&#10;        // Stop clipboard monitoring&#10;        ClipBoard clipBoard = Main.getClipBoard();&#10;        if (clipBoard != null) {&#10;            clipBoard.stop();&#10;        }&#10;&#10;        // Exit the application&#10;        Platform.exit();&#10;        System.exit(0);&#10;    }&#10;&#10;    private void loadIcon() {&#10;        try {&#10;            InputStream iconStream = Tools.getConfig().getRes(&quot;/icon.png&quot;);&#10;            if (iconStream != null) {&#10;                Image icon = new Image(iconStream);&#10;                primaryStage.getIcons().add(icon);&#10;                iconStream.close();&#10;                System.out.println(&quot;✓ Window icon loaded&quot;);&#10;            } else {&#10;                System.err.println(&quot;Warning: Could not load icon.png from resources&quot;);&#10;            }&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Could not load icon: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private HBox createToolbar() {&#10;        HBox toolbar = new HBox(10);&#10;        toolbar.getStyleClass().add(&quot;toolbar&quot;);&#10;        toolbar.setAlignment(Pos.CENTER_LEFT);&#10;&#10;        // Left side - Language selection&#10;        HBox languagePanel = new HBox(10);&#10;        languagePanel.setAlignment(Pos.CENTER_LEFT);&#10;&#10;        // Load languages from JSON file&#10;        LanguageItem[] languages = loadLanguagesFromJson();&#10;&#10;        sourceLanguageCombo = createStyledComboBox(languages);&#10;        sourceLanguageCombo.getSelectionModel().selectFirst(); // Default to Auto Detect&#10;&#10;        Label arrowLabel = new Label(&quot;→&quot;);&#10;        arrowLabel.getStyleClass().add(&quot;arrow-label&quot;);&#10;&#10;        // Find Bengali index&#10;        int bengaliIndex = 0;&#10;        for (int i = 0; i &lt; languages.length; i++) {&#10;            if (&quot;bn&quot;.equals(languages[i].code)) {&#10;                bengaliIndex = i;&#10;                break;&#10;            }&#10;        }&#10;&#10;        targetLanguageCombo = createStyledComboBox(languages);&#10;        targetLanguageCombo.getSelectionModel().select(bengaliIndex); // Default to Bengali&#10;&#10;        // Language selection listeners&#10;        sourceLanguageCombo.setOnAction(e -&gt; {&#10;            LanguageItem selected = sourceLanguageCombo.getValue();&#10;            if (selected != null) {&#10;                Tools.getConfig().setSourceLanguage(selected.code);&#10;            }&#10;        });&#10;&#10;        targetLanguageCombo.setOnAction(e -&gt; {&#10;            LanguageItem selected = targetLanguageCombo.getValue();&#10;            if (selected != null) {&#10;                Tools.getConfig().setTargetLanguage(selected.code);&#10;            }&#10;        });&#10;&#10;        // Initialize default languages&#10;        Tools.getConfig().setSourceLanguage(&quot;auto&quot;);&#10;        Tools.getConfig().setTargetLanguage(&quot;bn&quot;);&#10;&#10;        languagePanel.getChildren().addAll(sourceLanguageCombo, arrowLabel, targetLanguageCombo);&#10;&#10;        // Right side - Control buttons&#10;        HBox rightPanel = new HBox(8);&#10;        rightPanel.setAlignment(Pos.CENTER_RIGHT);&#10;&#10;        // Always-on-top toggle button&#10;        alwaysOnTopButton = createIconButton(&quot;PIN&quot;, &quot;Toggle Always On Top&quot;);&#10;        alwaysOnTopButton.getStyleClass().add(&quot;active&quot;); // Start active&#10;        alwaysOnTopButton.setOnAction(e -&gt; toggleAlwaysOnTop());&#10;        rightPanel.getChildren().add(alwaysOnTopButton);&#10;&#10;        // History button&#10;        Button historyButton = createIconButton(&quot;HIST&quot;, &quot;Show History&quot;);&#10;        historyButton.setOnAction(e -&gt; showHistoryDialog());&#10;        rightPanel.getChildren().add(historyButton);&#10;&#10;        // Spacer&#10;        Region spacer = new Region();&#10;        HBox.setHgrow(spacer, Priority.ALWAYS);&#10;&#10;        toolbar.getChildren().addAll(languagePanel, spacer, rightPanel);&#10;&#10;        return toolbar;&#10;    }&#10;&#10;    private StackPane createMainContent() {&#10;        StackPane stack = new StackPane();&#10;&#10;        // Background: Two text panels&#10;        HBox textPanels = new HBox(1);&#10;        VBox leftPanel = createTextPanel(&quot;Source Text&quot;, true);&#10;        VBox rightPanel = createTextPanel(&quot;Translation&quot;, false);&#10;        textPanels.getChildren().addAll(leftPanel, rightPanel);&#10;        HBox.setHgrow(leftPanel, Priority.ALWAYS);&#10;        HBox.setHgrow(rightPanel, Priority.ALWAYS);&#10;&#10;        // Foreground: Translate button&#10;        Button translateBtn = createTranslateButton();&#10;        StackPane.setAlignment(translateBtn, Pos.BOTTOM_CENTER);&#10;        StackPane.setMargin(translateBtn, new Insets(0, 0, 60, 0));&#10;&#10;        stack.getChildren().addAll(textPanels, translateBtn);&#10;        return stack;&#10;    }&#10;&#10;    private VBox createTextPanel(String title, boolean isSource) {&#10;        VBox panel = new VBox();&#10;        panel.getStyleClass().add(&quot;main-container&quot;);&#10;&#10;        // Header&#10;        HBox header = new HBox();&#10;        header.getStyleClass().add(&quot;panel-header&quot;);&#10;&#10;        Label titleLabel = new Label(title);&#10;        titleLabel.getStyleClass().add(&quot;panel-title&quot;);&#10;        header.getChildren().add(titleLabel);&#10;&#10;        panel.getChildren().add(header);&#10;&#10;        // Text area&#10;        TextArea textArea = new TextArea();&#10;        textArea.getStyleClass().add(&quot;text-area&quot;);&#10;        textArea.setWrapText(false); // Preserve formatting&#10;        VBox.setVgrow(textArea, Priority.ALWAYS);&#10;&#10;        if (isSource) {&#10;            sourceTextArea = textArea;&#10;            textArea.setPromptText(&quot;Enter text to translate...&quot;);&#10;&#10;            // Add Ctrl+Enter handler for quick translation&#10;            textArea.setOnKeyPressed(event -&gt; {&#10;                if (event.getCode() == KeyCode.ENTER &amp;&amp; event.isControlDown()) {&#10;                    performTranslation();&#10;                    event.consume();&#10;                }&#10;            });&#10;        } else {&#10;            translationTextArea = textArea;&#10;            textArea.setEditable(false);&#10;        }&#10;&#10;        panel.getChildren().add(textArea);&#10;&#10;        return panel;&#10;    }&#10;&#10;    private HBox createStatusBar() {&#10;        HBox statusBar = new HBox();&#10;        statusBar.getStyleClass().add(&quot;status-bar&quot;);&#10;&#10;        Label statusLabel = new Label(&quot;Monitoring clipboard • Press Ctrl+Enter to translate&quot;);&#10;        statusLabel.getStyleClass().add(&quot;status-label&quot;);&#10;&#10;        statusBar.getChildren().add(statusLabel);&#10;&#10;        return statusBar;&#10;    }&#10;&#10;    private Button createTranslateButton() {&#10;        Button btn = new Button();&#10;        btn.getStyleClass().add(&quot;translate-button&quot;);&#10;&#10;        // Create triangle shape (play/forward icon)&#10;        Polygon triangle = new Polygon();&#10;        triangle.getPoints().addAll(-8.0, -10.0, 10.0, 0.0, -8.0, 10.0);&#10;        triangle.setFill(Color.WHITE);&#10;        btn.setGraphic(triangle);&#10;&#10;        btn.setTooltip(new Tooltip(&quot;Translate (or press Ctrl+Enter)&quot;));&#10;        btn.setOnAction(e -&gt; performTranslation());&#10;&#10;        return btn;&#10;    }&#10;&#10;    private ComboBox&lt;LanguageItem&gt; createStyledComboBox(LanguageItem[] items) {&#10;        ComboBox&lt;LanguageItem&gt; comboBox = new ComboBox&lt;&gt;();&#10;        comboBox.getItems().addAll(items);&#10;&#10;        // Custom cell renderer&#10;        comboBox.setCellFactory(lv -&gt; new ListCell&lt;&gt;() {&#10;            @Override&#10;            protected void updateItem(LanguageItem item, boolean empty) {&#10;                super.updateItem(item, empty);&#10;                if (empty || item == null) {&#10;                    setText(null);&#10;                } else {&#10;                    setText(item.name);&#10;                }&#10;            }&#10;        });&#10;&#10;        comboBox.setButtonCell(new ListCell&lt;&gt;() {&#10;            @Override&#10;            protected void updateItem(LanguageItem item, boolean empty) {&#10;                super.updateItem(item, empty);&#10;                if (empty || item == null) {&#10;                    setText(null);&#10;                } else {&#10;                    setText(item.name);&#10;                }&#10;            }&#10;        });&#10;&#10;        return comboBox;&#10;    }&#10;&#10;    private Button createIconButton(String text, String tooltip) {&#10;        Button button = new Button(text);&#10;        button.getStyleClass().add(&quot;icon-button&quot;);&#10;        button.setTooltip(new Tooltip(tooltip));&#10;        return button;&#10;    }&#10;&#10;    private void performTranslation() {&#10;        String text = sourceTextArea.getText().trim();&#10;        if (text.isEmpty()) {&#10;            return;&#10;        }&#10;&#10;        Tools.getConfig().regNewText(text);&#10;        Tools.getConfig().callEvent(&quot;new_text&quot;);&#10;    }&#10;&#10;    private void showHistoryDialog() {&#10;        Stage dialog = new Stage();&#10;        dialog.initModality(Modality.APPLICATION_MODAL);&#10;        dialog.initOwner(primaryStage);&#10;        dialog.setTitle(&quot;Translation History&quot;);&#10;&#10;        BorderPane root = new BorderPane();&#10;        root.getStyleClass().add(&quot;main-container&quot;);&#10;&#10;        // Header&#10;        HBox header = new HBox();&#10;        header.getStyleClass().add(&quot;toolbar&quot;);&#10;        header.setAlignment(Pos.CENTER_LEFT);&#10;&#10;        Label title = new Label(&quot;Translation History&quot;);&#10;        title.getStyleClass().add(&quot;panel-title&quot;);&#10;        title.setStyle(&quot;-fx-font-size: 14px;&quot;);&#10;&#10;        Region spacer = new Region();&#10;        HBox.setHgrow(spacer, Priority.ALWAYS);&#10;&#10;        Button closeBtn = new Button(&quot;✕&quot;);&#10;        closeBtn.getStyleClass().add(&quot;icon-button&quot;);&#10;        closeBtn.setOnAction(e -&gt; dialog.close());&#10;&#10;        header.getChildren().addAll(title, spacer, closeBtn);&#10;        root.setTop(header);&#10;&#10;        // Content&#10;        TextArea historyArea = new TextArea();&#10;        historyArea.getStyleClass().add(&quot;text-area&quot;);&#10;        historyArea.setEditable(false);&#10;        historyArea.setWrapText(true);&#10;&#10;        StringBuilder historyText = new StringBuilder();&#10;        if (translationHistory.isEmpty()) {&#10;            historyText.append(&quot;No translation history yet.\n\nCopy text or use the Translate button to start.&quot;);&#10;        } else {&#10;            for (int i = translationHistory.size() - 1; i &gt;= 0; i--) {&#10;                historyText.append(translationHistory.get(i));&#10;                if (i &gt; 0) historyText.append(&quot;\n---\n\n&quot;);&#10;            }&#10;        }&#10;        historyArea.setText(historyText.toString());&#10;&#10;        root.setCenter(historyArea);&#10;&#10;        // Bottom buttons&#10;        HBox bottomPanel = new HBox(8);&#10;        bottomPanel.getStyleClass().add(&quot;status-bar&quot;);&#10;        bottomPanel.setAlignment(Pos.CENTER_RIGHT);&#10;&#10;        Button clearButton = new Button(&quot;Clear History&quot;);&#10;        clearButton.setOnAction(e -&gt; {&#10;            translationHistory.clear();&#10;            historyArea.setText(&quot;History cleared.&quot;);&#10;        });&#10;&#10;        bottomPanel.getChildren().add(clearButton);&#10;        root.setBottom(bottomPanel);&#10;&#10;        Scene scene = new Scene(root, 600, 400);&#10;&#10;        // Apply same stylesheet&#10;        try {&#10;            scene.getStylesheets().add(Objects.requireNonNull(getClass().getResource(&quot;/res/dark-theme.css&quot;)).toExternalForm());&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Warning: Could not load CSS for dialog: &quot; + e.getMessage());&#10;        }&#10;&#10;        dialog.setScene(scene);&#10;        dialog.showAndWait();&#10;    }&#10;&#10;    private void toggleAlwaysOnTop() {&#10;        isAlwaysOnTop = !isAlwaysOnTop;&#10;        primaryStage.setAlwaysOnTop(isAlwaysOnTop);&#10;&#10;        if (isAlwaysOnTop) {&#10;            alwaysOnTopButton.getStyleClass().add(&quot;active&quot;);&#10;            alwaysOnTopButton.setTooltip(new Tooltip(&quot;Always On Top (ON) - Click to disable&quot;));&#10;        } else {&#10;            alwaysOnTopButton.getStyleClass().remove(&quot;active&quot;);&#10;            alwaysOnTopButton.setTooltip(new Tooltip(&quot;Always On Top (OFF) - Click to enable&quot;));&#10;        }&#10;    }&#10;&#10;    private void setupEventHandlers() {&#10;        Tools.getConfig().addEvent(() -&gt; {&#10;            // Get source and translation separately&#10;            String source = Tools.getConfig().getLatestSource();&#10;            String translation = Tools.getConfig().getLatestTranslation();&#10;&#10;            if (source != null &amp;&amp; !source.isEmpty() &amp;&amp; translation != null &amp;&amp; !translation.isEmpty()) {&#10;                sourceTextArea.setText(source);&#10;                translationTextArea.setText(translation);&#10;&#10;                // Add formatted version to history&#10;                String historyEntry = Tools.getConfig().getLatestTranslationFormatted();&#10;                translationHistory.add(historyEntry);&#10;                if (translationHistory.size() &gt; 50) {&#10;                    translationHistory.remove(0);&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    // Load languages from JSON file&#10;    private LanguageItem[] loadLanguagesFromJson() {&#10;        try {&#10;            InputStream langStream = Tools.getConfig().getRes(&quot;/languages.json&quot;);&#10;            if (langStream == null) {&#10;                System.err.println(&quot;Warning: languages.json not found, using fallback languages&quot;);&#10;                return getFallbackLanguages();&#10;            }&#10;&#10;            Gson gson = new Gson();&#10;            JsonObject jsonObject = gson.fromJson(new InputStreamReader(langStream), JsonObject.class);&#10;            JsonArray languagesArray = jsonObject.getAsJsonArray(&quot;languages&quot;);&#10;&#10;            List&lt;LanguageItem&gt; languageList = new ArrayList&lt;&gt;();&#10;            for (int i = 0; i &lt; languagesArray.size(); i++) {&#10;                JsonObject langObj = languagesArray.get(i).getAsJsonObject();&#10;                String code = langObj.get(&quot;code&quot;).getAsString();&#10;                String name = langObj.get(&quot;name&quot;).getAsString();&#10;                languageList.add(new LanguageItem(code, name));&#10;            }&#10;&#10;            System.out.println(&quot;Successfully loaded &quot; + languageList.size() + &quot; languages from languages.json&quot;);&#10;            return languageList.toArray(new LanguageItem[0]);&#10;&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Error loading languages.json: &quot; + e.getMessage());&#10;            return getFallbackLanguages();&#10;        }&#10;    }&#10;&#10;    // Fallback languages if JSON loading fails&#10;    private LanguageItem[] getFallbackLanguages() {&#10;        return new LanguageItem[]{&#10;            new LanguageItem(&quot;auto&quot;, &quot;Auto Detect&quot;),&#10;            new LanguageItem(&quot;en&quot;, &quot;English&quot;),&#10;            new LanguageItem(&quot;bn&quot;, &quot;Bengali&quot;),&#10;            new LanguageItem(&quot;hi&quot;, &quot;Hindi&quot;),&#10;            new LanguageItem(&quot;ja&quot;, &quot;Japanese&quot;),&#10;            new LanguageItem(&quot;zh-CN&quot;, &quot;Chinese (Simplified)&quot;),&#10;            new LanguageItem(&quot;zh-TW&quot;, &quot;Chinese (Traditional)&quot;),&#10;            new LanguageItem(&quot;ko&quot;, &quot;Korean&quot;),&#10;            new LanguageItem(&quot;ar&quot;, &quot;Arabic&quot;),&#10;            new LanguageItem(&quot;es&quot;, &quot;Spanish&quot;),&#10;            new LanguageItem(&quot;fr&quot;, &quot;French&quot;),&#10;            new LanguageItem(&quot;de&quot;, &quot;German&quot;),&#10;            new LanguageItem(&quot;it&quot;, &quot;Italian&quot;),&#10;            new LanguageItem(&quot;pt&quot;, &quot;Portuguese&quot;),&#10;            new LanguageItem(&quot;ru&quot;, &quot;Russian&quot;),&#10;            new LanguageItem(&quot;tr&quot;, &quot;Turkish&quot;),&#10;            new LanguageItem(&quot;vi&quot;, &quot;Vietnamese&quot;),&#10;            new LanguageItem(&quot;th&quot;, &quot;Thai&quot;)&#10;        };&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.iishanto;&#10;&#10;import javafx.application.Application;&#10;import javafx.application.Platform;&#10;import javafx.geometry.Insets;&#10;import javafx.geometry.Pos;&#10;import javafx.scene.Scene;&#10;import javafx.scene.control.*;&#10;import javafx.scene.input.KeyCode;&#10;import javafx.scene.layout.*;&#10;import javafx.scene.paint.Color;&#10;import javafx.scene.shape.Polygon;&#10;import javafx.scene.text.Font;&#10;import javafx.stage.Modality;&#10;import javafx.stage.Stage;&#10;import javafx.scene.image.Image;&#10;import javafx.animation.RotateTransition;&#10;import javafx.scene.shape.Circle;&#10;import javafx.scene.shape.Arc;&#10;import javafx.scene.shape.ArcType;&#10;import javafx.util.Duration;&#10;&#10;import java.io.InputStream;&#10;import java.io.InputStreamReader;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Objects;&#10;&#10;import com.google.gson.Gson;&#10;import com.google.gson.JsonObject;&#10;import com.google.gson.JsonArray;&#10;&#10;public class WindowFX extends Application {&#10;    private Stage primaryStage;&#10;    private ComboBox&lt;LanguageItem&gt; sourceLanguageCombo;&#10;    private ComboBox&lt;LanguageItem&gt; targetLanguageCombo;&#10;    private TextArea sourceTextArea;&#10;    private TextArea translationTextArea;&#10;    private final List&lt;String&gt; translationHistory = new ArrayList&lt;&gt;();&#10;    private boolean isAlwaysOnTop = true;&#10;    private Button alwaysOnTopButton;&#10;    private Button translateButton;&#10;    private Polygon triangleIcon;&#10;    private Arc spinnerIcon;&#10;    private RotateTransition spinnerAnimation;&#10;&#10;    // Language class to hold language code and display name&#10;    private static class LanguageItem {&#10;        String code;&#10;        String name;&#10;&#10;        LanguageItem(String code, String name) {&#10;            this.code = code;&#10;            this.name = name;&#10;        }&#10;&#10;        @Override&#10;        public String toString() {&#10;            return name;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void start(Stage stage) {&#10;        this.primaryStage = stage;&#10;        primaryStage.setTitle(&quot;Universal Translator&quot;);&#10;        primaryStage.setAlwaysOnTop(true);&#10;&#10;        // Initialize font rendering system&#10;        initializeFontRendering();&#10;&#10;        // Load icon&#10;        loadIcon();&#10;&#10;        // Create UI&#10;        BorderPane root = new BorderPane();&#10;        root.getStyleClass().add(&quot;main-container&quot;);&#10;&#10;        // Top toolbar&#10;        HBox toolbar = createToolbar();&#10;        root.setTop(toolbar);&#10;&#10;        // Main content with overlay button&#10;        StackPane mainContent = createMainContent();&#10;        root.setCenter(mainContent);&#10;&#10;        // Status bar&#10;        HBox statusBar = createStatusBar();&#10;        root.setBottom(statusBar);&#10;&#10;        Scene scene = new Scene(root, 600, 300);&#10;&#10;        // Load CSS stylesheet&#10;        try {&#10;            InputStream cssStream = getClass().getResourceAsStream(&quot;/res/dark-theme.css&quot;);&#10;            if (cssStream != null) {&#10;                cssStream.close();&#10;                scene.getStylesheets().add(getClass().getResource(&quot;/res/dark-theme.css&quot;).toExternalForm());&#10;                System.out.println(&quot;✓ Dark theme CSS loaded successfully&quot;);&#10;            }&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Warning: Could not load dark-theme.css: &quot; + e.getMessage());&#10;        }&#10;&#10;        primaryStage.setScene(scene);&#10;        primaryStage.setMinWidth(600);&#10;        primaryStage.setMinHeight(100);&#10;&#10;        // Add shutdown hook for proper cleanup&#10;        primaryStage.setOnCloseRequest(event -&gt; {&#10;            System.out.println(&quot;Application closing...&quot;);&#10;            shutdown();&#10;        });&#10;&#10;        // Setup event handlers after UI is created&#10;        Platform.runLater(this::setupEventHandlers);&#10;&#10;        primaryStage.show();&#10;&#10;        System.out.println(&quot;=== JavaFX Window Initialized ===&quot;);&#10;        System.out.println(&quot;✓ Using OS native font rendering&quot;);&#10;        System.out.println(&quot;✓ Hardware-accelerated rendering enabled&quot;);&#10;    }&#10;&#10;    /**&#10;     * Initialize OS font rendering system with proper fallback for international characters&#10;     */&#10;    private void initializeFontRendering() {&#10;        System.out.println(&quot;=== Initializing OS Font Rendering ===&quot;);&#10;&#10;        // Load system fonts explicitly&#10;        loadSystemFonts();&#10;&#10;        // Get all available system fonts&#10;        List&lt;String&gt; fontFamilies = Font.getFamilies();&#10;&#10;        // Check for important international fonts&#10;        boolean hasJapanese = false;&#10;        boolean hasChinese = false;&#10;        boolean hasBengali = false;&#10;        boolean hasArabic = false;&#10;        boolean hasKorean = false;&#10;&#10;        List&lt;String&gt; cjkFonts = new ArrayList&lt;&gt;();&#10;        List&lt;String&gt; indicFonts = new ArrayList&lt;&gt;();&#10;        List&lt;String&gt; arabicFonts = new ArrayList&lt;&gt;();&#10;&#10;        for (String family : fontFamilies) {&#10;            String lowerFamily = family.toLowerCase();&#10;&#10;            // Japanese fonts&#10;            if (lowerFamily.contains(&quot;noto serif cjk jp&quot;) ||&#10;                lowerFamily.contains(&quot;noto sans cjk jp&quot;) ||&#10;                lowerFamily.contains(&quot;noto sans jp&quot;) ||&#10;                lowerFamily.contains(&quot;ms gothic&quot;) ||&#10;                lowerFamily.contains(&quot;meiryo&quot;) ||&#10;                lowerFamily.contains(&quot;hiragino&quot;) ||&#10;                lowerFamily.contains(&quot;ipagothic&quot;) ||&#10;                lowerFamily.contains(&quot;takao&quot;)) {&#10;                hasJapanese = true;&#10;                cjkFonts.add(family);&#10;            }&#10;&#10;            // Chinese fonts&#10;            if (lowerFamily.contains(&quot;noto serif cjk&quot;) ||&#10;                lowerFamily.contains(&quot;noto sans cjk&quot;) ||&#10;                lowerFamily.contains(&quot;noto sans sc&quot;) ||&#10;                lowerFamily.contains(&quot;noto sans tc&quot;) ||&#10;                lowerFamily.contains(&quot;microsoft yahei&quot;) ||&#10;                lowerFamily.contains(&quot;simsun&quot;) ||&#10;                lowerFamily.contains(&quot;wqy&quot;)) {&#10;                hasChinese = true;&#10;                cjkFonts.add(family);&#10;            }&#10;&#10;            // Korean fonts&#10;            if (lowerFamily.contains(&quot;noto sans kr&quot;) ||&#10;                lowerFamily.contains(&quot;noto serif cjk kr&quot;) ||&#10;                lowerFamily.contains(&quot;noto sans cjk kr&quot;) ||&#10;                lowerFamily.contains(&quot;malgun&quot;) ||&#10;                lowerFamily.contains(&quot;nanum&quot;)) {&#10;                hasKorean = true;&#10;                cjkFonts.add(family);&#10;            }&#10;&#10;            // Bengali fonts&#10;            if (lowerFamily.contains(&quot;noto sans bengali&quot;) ||&#10;                lowerFamily.contains(&quot;kalpurush&quot;) ||&#10;                lowerFamily.contains(&quot;lohit bengali&quot;) ||&#10;                lowerFamily.contains(&quot;mukti&quot;)) {&#10;                hasBengali = true;&#10;                indicFonts.add(family);&#10;            }&#10;&#10;            // Arabic fonts&#10;            if (lowerFamily.contains(&quot;noto sans arabic&quot;) ||&#10;                lowerFamily.contains(&quot;arabic&quot;) ||&#10;                lowerFamily.contains(&quot;droid arabic&quot;)) {&#10;                hasArabic = true;&#10;                arabicFonts.add(family);&#10;            }&#10;        }&#10;&#10;        // Report font availability&#10;        System.out.println(&quot;Font Support Status:&quot;);&#10;        System.out.println(&quot;  Japanese: &quot; + (hasJapanese ? &quot;✓ Available&quot; : &quot;✗ Missing&quot;));&#10;        System.out.println(&quot;  Chinese: &quot; + (hasChinese ? &quot;✓ Available&quot; : &quot;✗ Missing&quot;));&#10;        System.out.println(&quot;  Korean: &quot; + (hasKorean ? &quot;✓ Available&quot; : &quot;✗ Missing&quot;));&#10;        System.out.println(&quot;  Bengali: &quot; + (hasBengali ? &quot;✓ Available&quot; : &quot;✗ Missing&quot;));&#10;        System.out.println(&quot;  Arabic: &quot; + (hasArabic ? &quot;✓ Available&quot; : &quot;✗ Missing&quot;));&#10;&#10;        if (!cjkFonts.isEmpty()) {&#10;            System.out.println(&quot;\nAvailable CJK Fonts: &quot; + String.join(&quot;, &quot;, cjkFonts.subList(0, Math.min(3, cjkFonts.size()))));&#10;        }&#10;        if (!indicFonts.isEmpty()) {&#10;            System.out.println(&quot;Available Indic Fonts: &quot; + String.join(&quot;, &quot;, indicFonts));&#10;        }&#10;        if (!arabicFonts.isEmpty()) {&#10;            System.out.println(&quot;Available Arabic Fonts: &quot; + String.join(&quot;, &quot;, arabicFonts));&#10;        }&#10;&#10;        // Test character rendering&#10;        testFontRendering();&#10;&#10;        // Set system properties for better font rendering&#10;        System.setProperty(&quot;prism.lcdtext&quot;, &quot;true&quot;);&#10;        System.setProperty(&quot;prism.text&quot;, &quot;t2k&quot;);&#10;        System.setProperty(&quot;prism.allowhidpi&quot;, &quot;true&quot;);&#10;&#10;        System.out.println(&quot;✓ Font rendering system initialized&quot;);&#10;    }&#10;&#10;    /**&#10;     * Explicitly load system fonts from common paths&#10;     */&#10;    private void loadSystemFonts() {&#10;        String[] fontPaths = {&#10;            &quot;/usr/share/fonts/opentype/noto/&quot;,&#10;            &quot;/usr/share/fonts/truetype/noto/&quot;,&#10;            &quot;/usr/share/fonts/opentype/&quot;,&#10;            &quot;/usr/share/fonts/truetype/&quot;,&#10;            &quot;/usr/local/share/fonts/&quot;,&#10;            System.getProperty(&quot;user.home&quot;) + &quot;/.fonts/&quot;&#10;        };&#10;&#10;        for (String path : fontPaths) {&#10;            java.io.File fontDir = new java.io.File(path);&#10;            if (fontDir.exists() &amp;&amp; fontDir.isDirectory()) {&#10;                java.io.File[] fontFiles = fontDir.listFiles((dir, name) -&gt; {&#10;                    String lower = name.toLowerCase();&#10;                    return (lower.endsWith(&quot;.ttf&quot;) || lower.endsWith(&quot;.ttc&quot;) || lower.endsWith(&quot;.otf&quot;)) &amp;&amp;&#10;                           (lower.contains(&quot;noto&quot;) || lower.contains(&quot;cjk&quot;) || lower.contains(&quot;bengali&quot;));&#10;                });&#10;&#10;                if (fontFiles != null) {&#10;                    for (java.io.File fontFile : fontFiles) {&#10;                        try {&#10;                            Font.loadFont(new java.io.FileInputStream(fontFile), 14);&#10;                            System.out.println(&quot;  Loaded: &quot; + fontFile.getName());&#10;                        } catch (Exception e) {&#10;                            // Silently skip fonts that can't be loaded&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Test if critical characters can be rendered&#10;     */&#10;    private void testFontRendering() {&#10;        Font testFont = Font.getDefault();&#10;&#10;        // Test characters from different scripts&#10;        char[] testChars = {&#10;            'あ', // Japanese Hiragana&#10;            'ア', // Japanese Katakana&#10;            '漢', // Chinese/Japanese Kanji&#10;            'ব', // Bengali&#10;            'م', // Arabic&#10;            '한', // Korean Hangul&#10;            'ก', // Thai&#10;            'א'  // Hebrew&#10;        };&#10;&#10;        String[] scriptNames = {&#10;            &quot;Japanese (Hiragana)&quot;,&#10;            &quot;Japanese (Katakana)&quot;,&#10;            &quot;CJK (Kanji/Hanzi)&quot;,&#10;            &quot;Bengali&quot;,&#10;            &quot;Arabic&quot;,&#10;            &quot;Korean&quot;,&#10;            &quot;Thai&quot;,&#10;            &quot;Hebrew&quot;&#10;        };&#10;&#10;        System.out.println(&quot;\nCharacter Rendering Test:&quot;);&#10;        for (int i = 0; i &lt; testChars.length; i++) {&#10;            // Note: JavaFX doesn't have a direct canDisplay method, but the OS will handle fallback&#10;            System.out.println(&quot;  &quot; + scriptNames[i] + &quot; (&quot; + testChars[i] + &quot;): Will use OS font fallback&quot;);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void stop() throws Exception {&#10;        System.out.println(&quot;JavaFX Application stopping...&quot;);&#10;        shutdown();&#10;        super.stop();&#10;    }&#10;&#10;    private void shutdown() {&#10;        // Stop clipboard monitoring&#10;        ClipBoard clipBoard = Main.getClipBoard();&#10;        if (clipBoard != null) {&#10;            clipBoard.stop();&#10;        }&#10;&#10;        // Exit the application&#10;        Platform.exit();&#10;        System.exit(0);&#10;    }&#10;&#10;    private void loadIcon() {&#10;        try {&#10;            InputStream iconStream = Tools.getConfig().getRes(&quot;/icon.png&quot;);&#10;            if (iconStream != null) {&#10;                Image icon = new Image(iconStream);&#10;                primaryStage.getIcons().add(icon);&#10;                iconStream.close();&#10;                System.out.println(&quot;✓ Window icon loaded&quot;);&#10;            } else {&#10;                System.err.println(&quot;Warning: Could not load icon.png from resources&quot;);&#10;            }&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Could not load icon: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private HBox createToolbar() {&#10;        HBox toolbar = new HBox(10);&#10;        toolbar.getStyleClass().add(&quot;toolbar&quot;);&#10;        toolbar.setAlignment(Pos.CENTER_LEFT);&#10;&#10;        // Left side - Language selection&#10;        HBox languagePanel = new HBox(10);&#10;        languagePanel.setAlignment(Pos.CENTER_LEFT);&#10;&#10;        // Load languages from JSON file&#10;        LanguageItem[] languages = loadLanguagesFromJson();&#10;&#10;        sourceLanguageCombo = createStyledComboBox(languages);&#10;        sourceLanguageCombo.getSelectionModel().selectFirst(); // Default to Auto Detect&#10;&#10;        Label arrowLabel = new Label(&quot;→&quot;);&#10;        arrowLabel.getStyleClass().add(&quot;arrow-label&quot;);&#10;&#10;        // Find Bengali index&#10;        int bengaliIndex = 0;&#10;        for (int i = 0; i &lt; languages.length; i++) {&#10;            if (&quot;bn&quot;.equals(languages[i].code)) {&#10;                bengaliIndex = i;&#10;                break;&#10;            }&#10;        }&#10;&#10;        targetLanguageCombo = createStyledComboBox(languages);&#10;        targetLanguageCombo.getSelectionModel().select(bengaliIndex); // Default to Bengali&#10;&#10;        // Language selection listeners&#10;        sourceLanguageCombo.setOnAction(e -&gt; {&#10;            LanguageItem selected = sourceLanguageCombo.getValue();&#10;            if (selected != null) {&#10;                Tools.getConfig().setSourceLanguage(selected.code);&#10;            }&#10;        });&#10;&#10;        targetLanguageCombo.setOnAction(e -&gt; {&#10;            LanguageItem selected = targetLanguageCombo.getValue();&#10;            if (selected != null) {&#10;                Tools.getConfig().setTargetLanguage(selected.code);&#10;            }&#10;        });&#10;&#10;        // Initialize default languages&#10;        Tools.getConfig().setSourceLanguage(&quot;auto&quot;);&#10;        Tools.getConfig().setTargetLanguage(&quot;bn&quot;);&#10;&#10;        languagePanel.getChildren().addAll(sourceLanguageCombo, arrowLabel, targetLanguageCombo);&#10;&#10;        // Right side - Control buttons&#10;        HBox rightPanel = new HBox(8);&#10;        rightPanel.setAlignment(Pos.CENTER_RIGHT);&#10;&#10;        // Always-on-top toggle button&#10;        alwaysOnTopButton = createIconButton(&quot;PIN&quot;, &quot;Toggle Always On Top&quot;);&#10;        alwaysOnTopButton.getStyleClass().add(&quot;active&quot;); // Start active&#10;        alwaysOnTopButton.setOnAction(e -&gt; toggleAlwaysOnTop());&#10;        rightPanel.getChildren().add(alwaysOnTopButton);&#10;&#10;        // History button&#10;        Button historyButton = createIconButton(&quot;HIST&quot;, &quot;Show History&quot;);&#10;        historyButton.setOnAction(e -&gt; showHistoryDialog());&#10;        rightPanel.getChildren().add(historyButton);&#10;&#10;        // Spacer&#10;        Region spacer = new Region();&#10;        HBox.setHgrow(spacer, Priority.ALWAYS);&#10;&#10;        toolbar.getChildren().addAll(languagePanel, spacer, rightPanel);&#10;&#10;        return toolbar;&#10;    }&#10;&#10;    private StackPane createMainContent() {&#10;        StackPane stack = new StackPane();&#10;&#10;        // Background: Two text panels&#10;        HBox textPanels = new HBox(1);&#10;        VBox leftPanel = createTextPanel(&quot;Source Text&quot;, true);&#10;        VBox rightPanel = createTextPanel(&quot;Translation&quot;, false);&#10;        textPanels.getChildren().addAll(leftPanel, rightPanel);&#10;        HBox.setHgrow(leftPanel, Priority.ALWAYS);&#10;        HBox.setHgrow(rightPanel, Priority.ALWAYS);&#10;&#10;        // Foreground: Translate button&#10;        translateButton = createTranslateButton();&#10;        StackPane.setAlignment(translateButton, Pos.BOTTOM_CENTER);&#10;        StackPane.setMargin(translateButton, new Insets(0, 0, 60, 0));&#10;&#10;        stack.getChildren().addAll(textPanels, translateButton);&#10;        return stack;&#10;    }&#10;&#10;    private VBox createTextPanel(String title, boolean isSource) {&#10;        VBox panel = new VBox();&#10;        panel.getStyleClass().add(&quot;main-container&quot;);&#10;&#10;        // Header&#10;        HBox header = new HBox();&#10;        header.getStyleClass().add(&quot;panel-header&quot;);&#10;&#10;        Label titleLabel = new Label(title);&#10;        titleLabel.getStyleClass().add(&quot;panel-title&quot;);&#10;        header.getChildren().add(titleLabel);&#10;&#10;        panel.getChildren().add(header);&#10;&#10;        // Text area&#10;        TextArea textArea = new TextArea();&#10;        textArea.getStyleClass().add(&quot;text-area&quot;);&#10;        textArea.setWrapText(false); // Preserve formatting&#10;        VBox.setVgrow(textArea, Priority.ALWAYS);&#10;&#10;        if (isSource) {&#10;            sourceTextArea = textArea;&#10;            textArea.setPromptText(&quot;Enter text to translate...&quot;);&#10;&#10;            // Add Ctrl+Enter handler for quick translation&#10;            textArea.setOnKeyPressed(event -&gt; {&#10;                if (event.getCode() == KeyCode.ENTER &amp;&amp; event.isControlDown()) {&#10;                    performTranslation();&#10;                    event.consume();&#10;                }&#10;            });&#10;        } else {&#10;            translationTextArea = textArea;&#10;            textArea.setEditable(false);&#10;        }&#10;&#10;        panel.getChildren().add(textArea);&#10;&#10;        return panel;&#10;    }&#10;&#10;    private HBox createStatusBar() {&#10;        HBox statusBar = new HBox();&#10;        statusBar.getStyleClass().add(&quot;status-bar&quot;);&#10;&#10;        Label statusLabel = new Label(&quot;Monitoring clipboard • Press Ctrl+Enter to translate&quot;);&#10;        statusLabel.getStyleClass().add(&quot;status-label&quot;);&#10;&#10;        statusBar.getChildren().add(statusLabel);&#10;&#10;        return statusBar;&#10;    }&#10;&#10;    private Button createTranslateButton() {&#10;        Button btn = new Button();&#10;        btn.getStyleClass().add(&quot;translate-button&quot;);&#10;&#10;        // Create triangle shape (play/forward icon)&#10;        triangleIcon = new Polygon();&#10;        triangleIcon.getPoints().addAll(-8.0, -10.0, 10.0, 0.0, -8.0, 10.0);&#10;        triangleIcon.setFill(Color.WHITE);&#10;        btn.setGraphic(triangleIcon);&#10;&#10;        btn.setTooltip(new Tooltip(&quot;Translate (or press Ctrl+Enter)&quot;));&#10;        btn.setOnAction(e -&gt; performTranslation());&#10;&#10;        return btn;&#10;    }&#10;&#10;    private ComboBox&lt;LanguageItem&gt; createStyledComboBox(LanguageItem[] items) {&#10;        ComboBox&lt;LanguageItem&gt; comboBox = new ComboBox&lt;&gt;();&#10;        comboBox.getItems().addAll(items);&#10;&#10;        // Custom cell renderer&#10;        comboBox.setCellFactory(lv -&gt; new ListCell&lt;&gt;() {&#10;            @Override&#10;            protected void updateItem(LanguageItem item, boolean empty) {&#10;                super.updateItem(item, empty);&#10;                if (empty || item == null) {&#10;                    setText(null);&#10;                } else {&#10;                    setText(item.name);&#10;                }&#10;            }&#10;        });&#10;&#10;        comboBox.setButtonCell(new ListCell&lt;&gt;() {&#10;            @Override&#10;            protected void updateItem(LanguageItem item, boolean empty) {&#10;                super.updateItem(item, empty);&#10;                if (empty || item == null) {&#10;                    setText(null);&#10;                } else {&#10;                    setText(item.name);&#10;                }&#10;            }&#10;        });&#10;&#10;        return comboBox;&#10;    }&#10;&#10;    private Button createIconButton(String text, String tooltip) {&#10;        Button button = new Button(text);&#10;        button.getStyleClass().add(&quot;icon-button&quot;);&#10;        button.setTooltip(new Tooltip(tooltip));&#10;        return button;&#10;    }&#10;&#10;    private void performTranslation() {&#10;        String text = sourceTextArea.getText().trim();&#10;        if (text.isEmpty()) {&#10;            return;&#10;        }&#10;&#10;        // Show spinner immediately on UI thread&#10;        showSpinner();&#10;&#10;        Tools.getConfig().regNewText(text);&#10;        Tools.getConfig().callEvent(&quot;new_text&quot;);&#10;    }&#10;&#10;    private void showHistoryDialog() {&#10;        Stage dialog = new Stage();&#10;        dialog.initModality(Modality.APPLICATION_MODAL);&#10;        dialog.initOwner(primaryStage);&#10;        dialog.setTitle(&quot;Translation History&quot;);&#10;&#10;        BorderPane root = new BorderPane();&#10;        root.getStyleClass().add(&quot;main-container&quot;);&#10;&#10;        // Header&#10;        HBox header = new HBox();&#10;        header.getStyleClass().add(&quot;toolbar&quot;);&#10;        header.setAlignment(Pos.CENTER_LEFT);&#10;&#10;        Label title = new Label(&quot;Translation History&quot;);&#10;        title.getStyleClass().add(&quot;panel-title&quot;);&#10;        title.setStyle(&quot;-fx-font-size: 14px;&quot;);&#10;&#10;        Region spacer = new Region();&#10;        HBox.setHgrow(spacer, Priority.ALWAYS);&#10;&#10;        Button closeBtn = new Button(&quot;✕&quot;);&#10;        closeBtn.getStyleClass().add(&quot;icon-button&quot;);&#10;        closeBtn.setOnAction(e -&gt; dialog.close());&#10;&#10;        header.getChildren().addAll(title, spacer, closeBtn);&#10;        root.setTop(header);&#10;&#10;        // Content&#10;        TextArea historyArea = new TextArea();&#10;        historyArea.getStyleClass().add(&quot;text-area&quot;);&#10;        historyArea.setEditable(false);&#10;        historyArea.setWrapText(true);&#10;&#10;        StringBuilder historyText = new StringBuilder();&#10;        if (translationHistory.isEmpty()) {&#10;            historyText.append(&quot;No translation history yet.\n\nCopy text or use the Translate button to start.&quot;);&#10;        } else {&#10;            for (int i = translationHistory.size() - 1; i &gt;= 0; i--) {&#10;                historyText.append(translationHistory.get(i));&#10;                if (i &gt; 0) historyText.append(&quot;\n---\n\n&quot;);&#10;            }&#10;        }&#10;        historyArea.setText(historyText.toString());&#10;&#10;        root.setCenter(historyArea);&#10;&#10;        // Bottom buttons&#10;        HBox bottomPanel = new HBox(8);&#10;        bottomPanel.getStyleClass().add(&quot;status-bar&quot;);&#10;        bottomPanel.setAlignment(Pos.CENTER_RIGHT);&#10;&#10;        Button clearButton = new Button(&quot;Clear History&quot;);&#10;        clearButton.setOnAction(e -&gt; {&#10;            translationHistory.clear();&#10;            historyArea.setText(&quot;History cleared.&quot;);&#10;        });&#10;&#10;        bottomPanel.getChildren().add(clearButton);&#10;        root.setBottom(bottomPanel);&#10;&#10;        Scene scene = new Scene(root, 600, 400);&#10;&#10;        // Apply same stylesheet&#10;        try {&#10;            scene.getStylesheets().add(Objects.requireNonNull(getClass().getResource(&quot;/res/dark-theme.css&quot;)).toExternalForm());&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Warning: Could not load CSS for dialog: &quot; + e.getMessage());&#10;        }&#10;&#10;        dialog.setScene(scene);&#10;        dialog.showAndWait();&#10;    }&#10;&#10;    private void toggleAlwaysOnTop() {&#10;        isAlwaysOnTop = !isAlwaysOnTop;&#10;        primaryStage.setAlwaysOnTop(isAlwaysOnTop);&#10;&#10;        if (isAlwaysOnTop) {&#10;            alwaysOnTopButton.getStyleClass().add(&quot;active&quot;);&#10;            alwaysOnTopButton.setTooltip(new Tooltip(&quot;Always On Top (ON) - Click to disable&quot;));&#10;        } else {&#10;            alwaysOnTopButton.getStyleClass().remove(&quot;active&quot;);&#10;            alwaysOnTopButton.setTooltip(new Tooltip(&quot;Always On Top (OFF) - Click to enable&quot;));&#10;        }&#10;    }&#10;&#10;    private void setupEventHandlers() {&#10;        // Register translation start callback&#10;        Tools.getConfig().setTranslationStartCallback(() -&gt; {&#10;            // This runs when translation starts (on background thread)&#10;            Platform.runLater(this::showSpinner);&#10;        });&#10;        &#10;        Tools.getConfig().addEvent(() -&gt; {&#10;            // Get source and translation separately&#10;            String source = Tools.getConfig().getLatestSource();&#10;            String translation = Tools.getConfig().getLatestTranslation();&#10;&#10;            if (source != null &amp;&amp; !source.isEmpty() &amp;&amp; translation != null &amp;&amp; !translation.isEmpty()) {&#10;                // Update UI on JavaFX thread&#10;                Platform.runLater(() -&gt; {&#10;                    sourceTextArea.setText(source);&#10;                    translationTextArea.setText(translation);&#10;&#10;                    // Add formatted version to history&#10;                    String historyEntry = Tools.getConfig().getLatestTranslationFormatted();&#10;                    translationHistory.add(historyEntry);&#10;                    if (translationHistory.size() &gt; 50) {&#10;                        translationHistory.remove(0);&#10;                    }&#10;&#10;                    // Hide spinner when translation is complete&#10;                    hideSpinner();&#10;                });&#10;            }&#10;        });&#10;    }&#10;&#10;    // Load languages from JSON file&#10;    private LanguageItem[] loadLanguagesFromJson() {&#10;        try {&#10;            InputStream langStream = Tools.getConfig().getRes(&quot;/languages.json&quot;);&#10;            if (langStream == null) {&#10;                System.err.println(&quot;Warning: languages.json not found, using fallback languages&quot;);&#10;                return getFallbackLanguages();&#10;            }&#10;&#10;            Gson gson = new Gson();&#10;            JsonObject jsonObject = gson.fromJson(new InputStreamReader(langStream), JsonObject.class);&#10;            JsonArray languagesArray = jsonObject.getAsJsonArray(&quot;languages&quot;);&#10;&#10;            List&lt;LanguageItem&gt; languageList = new ArrayList&lt;&gt;();&#10;            for (int i = 0; i &lt; languagesArray.size(); i++) {&#10;                JsonObject langObj = languagesArray.get(i).getAsJsonObject();&#10;                String code = langObj.get(&quot;code&quot;).getAsString();&#10;                String name = langObj.get(&quot;name&quot;).getAsString();&#10;                languageList.add(new LanguageItem(code, name));&#10;            }&#10;&#10;            System.out.println(&quot;Successfully loaded &quot; + languageList.size() + &quot; languages from languages.json&quot;);&#10;            return languageList.toArray(new LanguageItem[0]);&#10;&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Error loading languages.json: &quot; + e.getMessage());&#10;            return getFallbackLanguages();&#10;        }&#10;    }&#10;&#10;    // Fallback languages if JSON loading fails&#10;    private LanguageItem[] getFallbackLanguages() {&#10;        return new LanguageItem[]{&#10;            new LanguageItem(&quot;auto&quot;, &quot;Auto Detect&quot;),&#10;            new LanguageItem(&quot;en&quot;, &quot;English&quot;),&#10;            new LanguageItem(&quot;bn&quot;, &quot;Bengali&quot;),&#10;            new LanguageItem(&quot;hi&quot;, &quot;Hindi&quot;),&#10;            new LanguageItem(&quot;ja&quot;, &quot;Japanese&quot;),&#10;            new LanguageItem(&quot;zh-CN&quot;, &quot;Chinese (Simplified)&quot;),&#10;            new LanguageItem(&quot;zh-TW&quot;, &quot;Chinese (Traditional)&quot;),&#10;            new LanguageItem(&quot;ko&quot;, &quot;Korean&quot;),&#10;            new LanguageItem(&quot;ar&quot;, &quot;Arabic&quot;),&#10;            new LanguageItem(&quot;es&quot;, &quot;Spanish&quot;),&#10;            new LanguageItem(&quot;fr&quot;, &quot;French&quot;),&#10;            new LanguageItem(&quot;de&quot;, &quot;German&quot;),&#10;            new LanguageItem(&quot;it&quot;, &quot;Italian&quot;),&#10;            new LanguageItem(&quot;pt&quot;, &quot;Portuguese&quot;),&#10;            new LanguageItem(&quot;ru&quot;, &quot;Russian&quot;),&#10;            new LanguageItem(&quot;tr&quot;, &quot;Turkish&quot;),&#10;            new LanguageItem(&quot;vi&quot;, &quot;Vietnamese&quot;),&#10;            new LanguageItem(&quot;th&quot;, &quot;Thai&quot;)&#10;        };&#10;    }&#10;&#10;    /**&#10;     * Show the loading spinner on the translate button&#10;     */&#10;    private void showSpinner() {&#10;        // Create spinner icon if not already created&#10;        if (spinnerIcon == null) {&#10;            spinnerIcon = new Arc(0, 0, 10, 10, 90, 270);&#10;            spinnerIcon.setFill(Color.TRANSPARENT);&#10;            spinnerIcon.setStroke(Color.WHITE);&#10;            spinnerIcon.setStrokeWidth(3);&#10;            spinnerIcon.setType(ArcType.OPEN);&#10;&#10;            // Create rotation animation for spinner&#10;            spinnerAnimation = new RotateTransition(Duration.seconds(1), spinnerIcon);&#10;            spinnerAnimation.setFromAngle(0);&#10;            spinnerAnimation.setToAngle(360);&#10;            spinnerAnimation.setCycleCount(RotateTransition.INDEFINITE);&#10;        }&#10;&#10;        // Switch to spinner graphic&#10;        translateButton.setGraphic(spinnerIcon);&#10;        &#10;        // Start spinner animation&#10;        spinnerAnimation.play();&#10;    }&#10;&#10;    /**&#10;     * Hide the loading spinner on the translate button&#10;     */&#10;    private void hideSpinner() {&#10;        if (spinnerAnimation != null) {&#10;            // Stop spinner animation&#10;            spinnerAnimation.stop();&#10;        }&#10;        // Restore triangle graphic&#10;        translateButton.setGraphic(triangleIcon);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>